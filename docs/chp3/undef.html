<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>On Undefined Behavior - High Assurance Rust: Developing Secure and Robust Software</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../landing.html">High Assurance Rust</a></li><li class="chapter-item expanded affix "><a href="../faq.html">Frequently Asked Questions (FAQ)</a></li><li class="chapter-item expanded affix "><a href="../engage.html">Engage with this Book!</a></li><li class="chapter-item expanded affix "><a href="../cfp.html">Sponsor Call for Proposals (CFP)</a></li><li class="chapter-item expanded affix "><a href="../download.html">Download</a></li><li class="chapter-item expanded affix "><a href="../changelog.html">Changelog</a></li><li class="chapter-item expanded affix "><a href="../license.html">License</a></li><li class="chapter-item expanded affix "><li class="part-title">Novice: Systems Security</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../chp1/_index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chp1/why_this_book.html"><strong aria-hidden="true">1.1.</strong> Why this book?</a></li><li class="chapter-item expanded "><a href="../chp1/how_is_this_book_structured.html"><strong aria-hidden="true">1.2.</strong> How is this book structured?</a></li><li class="chapter-item expanded "><a href="../chp1/challenges.html"><strong aria-hidden="true">1.3.</strong> Hands-on Learning</a></li><li class="chapter-item expanded "><a href="../chp1/about_the_team.html"><strong aria-hidden="true">1.4.</strong> About the Team</a></li><li class="chapter-item expanded "><a href="../chp1/_hands_on.html"><strong aria-hidden="true">1.5.</strong> Warmup: Environment Setup</a></li></ol></li><li class="chapter-item expanded "><a href="../chp2/_index.html"><strong aria-hidden="true">2.</strong> Software Assurance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chp2/static_vs_dynamic.html"><strong aria-hidden="true">2.1.</strong> Static vs. Dynamic Tools</a></li><li class="chapter-item expanded "><a href="../chp2/static_assurance_1.html"><strong aria-hidden="true">2.2.</strong> Static Assurance (1/2)</a></li><li class="chapter-item expanded "><a href="../chp2/static_assurance_2.html"><strong aria-hidden="true">2.3.</strong> Static Assurance (2/2)</a></li><li class="chapter-item expanded "><a href="../chp2/dynamic_assurance_1.html"><strong aria-hidden="true">2.4.</strong> Dynamic Assurance (1/3)</a></li><li class="chapter-item expanded "><a href="../chp2/dynamic_assurance_2.html"><strong aria-hidden="true">2.5.</strong> Dynamic Assurance (2/3)</a></li><li class="chapter-item expanded "><a href="../chp2/dynamic_assurance_3.html"><strong aria-hidden="true">2.6.</strong> Dynamic Assurance (3/3)</a></li><li class="chapter-item expanded "><a href="../chp2/limits.html"><strong aria-hidden="true">2.7.</strong> Limitations and Threat Modeling</a></li><li class="chapter-item expanded "><a href="../chp2/cli.html"><strong aria-hidden="true">2.8.</strong> DIY CLI Encryption Tool</a></li><li class="chapter-item expanded "><a href="../chp2/operational_assurance_1.html"><strong aria-hidden="true">2.9.</strong> Operational Assurance (1/2)</a></li><li class="chapter-item expanded "><a href="../chp2/operational_assurance_2.html"><strong aria-hidden="true">2.10.</strong> Operational Assurance (2/2)</a></li><li class="chapter-item expanded "><a href="../chp2/_hands_on.html"><strong aria-hidden="true">2.11.</strong> Challenge: Extend the CLI Tool</a></li></ol></li><li class="chapter-item expanded "><a href="../chp3/_index.html"><strong aria-hidden="true">3.</strong> Rust Zero-Crash Course</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chp3/undef.html" class="active"><strong aria-hidden="true">3.1.</strong> On Undefined Behavior</a></li><li class="chapter-item expanded "><a href="../chp3/rust_1_low_data_rep.html"><strong aria-hidden="true">3.2.</strong> Rust: Low-Level Data (1/6)</a></li><li class="chapter-item expanded "><a href="../chp3/rust_2_high_data_rep.html"><strong aria-hidden="true">3.3.</strong> Rust: High-Level Data (2/6)</a></li><li class="chapter-item expanded "><a href="../chp3/rust_3_ctrl_flow.html"><strong aria-hidden="true">3.4.</strong> Rust: Control Flow (3/6)</a></li><li class="chapter-item expanded "><a href="../chp3/rust_4_own_1.html"><strong aria-hidden="true">3.5.</strong> Rust: Ownership Principles (4/6)</a></li><li class="chapter-item expanded "><a href="../chp3/rust_5_own_2.html"><strong aria-hidden="true">3.6.</strong> Rust: Ownership in Practice (5/6)</a></li><li class="chapter-item expanded "><a href="../chp3/rust_6_error.html"><strong aria-hidden="true">3.7.</strong> Rust: Error Handling (6/6)</a></li><li class="chapter-item expanded "><a href="../chp3/modules.html"><strong aria-hidden="true">3.8.</strong> The Module System</a></li><li class="chapter-item expanded "><a href="../chp3/tooling.html"><strong aria-hidden="true">3.9.</strong> Recommended Tooling</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.10.</strong> Rust's Release Cycle</div></li><li class="chapter-item expanded "><a href="../chp3/_hands_on.html"><strong aria-hidden="true">3.11.</strong> Challenge: Port a Program</a></li></ol></li><li class="chapter-item expanded "><a href="../chp4/_index.html"><strong aria-hidden="true">4.</strong> Understanding Memory Safety and Exploitation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chp4/sw_stack_1.html"><strong aria-hidden="true">4.1.</strong> Software Perspective: CPU to Process</a></li><li class="chapter-item expanded "><a href="../chp4/assure_stack_1.html"><strong aria-hidden="true">4.2.</strong> Assurance Perspective: Stack Safety</a></li><li class="chapter-item expanded "><a href="../chp4/attack_1.html"><strong aria-hidden="true">4.3.</strong> Attacker's Perspective: Breaking Safety (1/2)</a></li><li class="chapter-item expanded "><a href="../chp4/attack_2.html"><strong aria-hidden="true">4.4.</strong> Attacker's Perspective: Unifying Theory (2/2)</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> Debugging DIY Secret Obfuscation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.6.</strong> Stack Exploitation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.7.</strong> Software Perspective: Heap (1/2)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.8.</strong> Software Perspective: Heap (2/2)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.9.</strong> Heap Exploitation</div></li><li class="chapter-item expanded "><a href="../chp4/safe_rust_PLACEHOLDER.html"><strong aria-hidden="true">4.10.</strong> Rust's Memory Safety Guarantees (1/2)</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.11.</strong> Rust's Memory Safety Guarantees (2/2)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.12.</strong> Language-agnostic Mitigations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.13.</strong> Case Study: Real-world Rust CVEs</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.14.</strong> Challenge: Vulnerability Research</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Advanced Beginner: Core Project</li><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Binary Search Tree (BST) Basics</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Core BST Operations in Python</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> Problems Translating to Rust</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> The Importance of Balance</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Building an Arena Allocator</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Let's Talk Allocators</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> A Stack-Only Arena</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Index-based Data Structures</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> A Self-balancing BST</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chp7/traits.html"><strong aria-hidden="true">7.1.</strong> Interface-relevant Traits</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.2.</strong> Scapegoat Trees</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.</strong> Insert</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.</strong> Remove</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.5.</strong> Find</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.6.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Digital Twin Testing</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> Basic QEMU Internals</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> How Semi-hosting Works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> CLI REPL Harness</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.4.</strong> Limitations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.5.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.6.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Building Maps and Sets</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Implementing Iterators</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">10.1.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.2.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Competent: Validation and Deployment</li><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Static Verification</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">11.1.</strong> An Introduction to 1st Order Logic</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.2.</strong> Proving Absence of Panics</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.3.</strong> Deductively Verifying our Arena Allocator</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.4.</strong> Model Checking for unsafe Code</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.5.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.6.</strong> Challenge: Prove a Sorting Algorithm</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Dynamic Testing</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">12.1.</strong> Introduction to Coverage-Guided Fuzzing</div></li><li class="chapter-item expanded "><a href="../chp12/diff_fuzz_PLACEHOLDER.html"><strong aria-hidden="true">12.2.</strong> Building a Differential Fuzzing Harness</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.3.</strong> Using Miri to Detect Undefined Behavior</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.4.</strong> Benchmarking and Optimization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.5.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.6.</strong> Challenge: Bug-hunting with Fuzzers</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Operational Deployment</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">13.1.</strong> Understanding unsafe (1/3)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.2.</strong> Understanding unsafe (2/3)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.3.</strong> Understanding unsafe (3/3)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.4.</strong> CFFI 101</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.5.</strong> C99 Interoperability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.6.</strong> Python3 Interoperability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.7.</strong> Runtime Balance Reconfiguration</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.8.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.9.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Maximizing Assurance</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">14.1.</strong> Rust Security Research</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.2.</strong> Rust's Limitations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.3.</strong> Best Practices Beyond Rust</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.4.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.5.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Conclusion</li><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Review</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">15.1.</strong> Key Concepts</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.2.</strong> Key Blue-Team Skills</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.3.</strong> Key Red-Team Skills</div></li></ol></li><li class="chapter-item expanded "><a href="../chp16_appendix/_index.html"><strong aria-hidden="true">16.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">16.1.</strong> Setup: Using our Docker Container</div></li><li class="chapter-item expanded "><a href="../chp16_appendix/tools.html"><strong aria-hidden="true">16.2.</strong> Inventory: Tools of the Trade</a></li><li class="chapter-item expanded "><a href="../chp16_appendix/books.html"><strong aria-hidden="true">16.3.</strong> Inventory: Recommended Reading</a></li><li class="chapter-item expanded "><a href="../chp16_appendix/resources.html"><strong aria-hidden="true">16.4.</strong> Inventory: Additional Resources</a></li><li class="chapter-item expanded "><a href="../chp16_appendix/crypto.html"><strong aria-hidden="true">16.5.</strong> Fundamentals: Stream Ciphers</a></li><li class="chapter-item expanded "><a href="../chp16_appendix/types.html"><strong aria-hidden="true">16.6.</strong> Fundamentals: Type Systems</a></li><li class="chapter-item expanded "><a href="../chp16_appendix/components.html"><strong aria-hidden="true">16.7.</strong> Fundamentals: Component-Based Design</a></li><li class="chapter-item expanded "><a href="../chp16_appendix/mem_hierarch.html"><strong aria-hidden="true">16.8.</strong> Fundamentals: Memory Hierarchy</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.9.</strong> Fundamentals: Dynamic Linking</div></li><li class="chapter-item expanded "><a href="../chp16_appendix/icfg.html"><strong aria-hidden="true">16.10.</strong> Theory: Inter-procedural CFGs</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.11.</strong> Misc: Size Optimization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.12.</strong> Misc: The Typestate Pattern</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.13.</strong> Misc: C++ Interoperability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.14.</strong> Misc: Compile-time Metaprogramming</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">High Assurance Rust: Developing Secure and Robust Software</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/tnballo/high-assurance-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://highassurance.rs/engage.html#submit-feedback-questions-issues-or-prs" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="on-undefined-behavior"><a class="header" href="#on-undefined-behavior">On Undefined Behavior</a></h1>
<p>One of MISRA C's driving goals is reducing the amount of &quot;Undefined Behavior&quot; (UB) <sup class="footnote-reference"><a href="#MISRA_TALK">1</a></sup> present in a codebase.
We made passing mention of UB in Chapter 1, but it's an essential concept.
Eliminating UB is necessary, but not sufficient, for high assurance software.
So let's tackle the topic now, before we get into Rust syntax.</p>
<p>The ISO C standard<sup class="footnote-reference"><a href="#ISOC">2</a></sup> defines <strong>behavior</strong> as:</p>
<blockquote>
<p>External appearance or action.</p>
</blockquote>
<p>Consequently, <strong>Undefined Behavior (UB)</strong> is defined as<sup class="footnote-reference"><a href="#ISOC">2</a></sup>:</p>
<blockquote>
<p>Behavior, upon use of a nonportable or erroneous program construct or of erroneous data, for which this International Standard imposes no requirements.</p>
</blockquote>
<p>In other words, should a developer inadvertently trigger UB, <em>the program can do absolutely anything</em>.
It may crash, produce an incorrect result, or even execute a sequence of seemingly unrelated operations<sup class="footnote-reference"><a href="#NasalDemons">3</a></sup>.</p>
<p>Notice we didn't say &quot;the undefined operation can do absolutely anything&quot;, we said &quot;the program&quot;.
It's important to understand one fact about UB:</p>
<ul>
<li>Once undefined behavior is triggered, the adverse impact often cannot be <em>localized</em>. It may compromise the security and/or reliability of the <em>entire</em> system.</li>
</ul>
<p>UB is an undesirable source of bugs and vulnerabilities.
Yet UB is ingrained into both C and C++ standards for a variety of complex historical reasons.
Removing even a small portion of UB from either language would break a large percentage of available compilers or their ability to compile existing code.
So it's unlikely to happen.</p>
<p>The best we can do is make a diligent effort to avoid it.
That means heavy auditing and thorough testing of C-family codebases and, where possible, introducing Rust.</p>
<h2 id="how-easy-is-it-to-introduce-ub-in-c"><a class="header" href="#how-easy-is-it-to-introduce-ub-in-c">How easy is it to introduce UB in C?</a></h2>
<p>C and C++ programs are, relative to memory-safe languages, difficult to debug and easy to exploit because introducing UB is both <em>trivial</em> and <em>common</em>.</p>
<p>Researchers have found instances of UB in widely used projects, like the Linux kernel and PostgreSQL<sup class="footnote-reference"><a href="#UndefResearch">4</a></sup>.
Memory corruption bugs, whose severity and prevalence we discussed in Chapter 1, are just one consequence of UB.</p>
<p>Let's get a tangible feel for what UB looks like.
Consider the below C program - what does it return?</p>
<pre><code class="language-c ignore">#include &lt;stdio.h&gt;

int undef_func() {
    int uninit_var; // Never assigned to!
    if (uninit_var &gt; 0) {
        return 1;
    } else {
        return 0;
    }
}

int main() {
    printf(&quot;%d\n&quot;, undef_func());
}
</code></pre>
<p>That was a trick question.
The answer is <code>1</code> or <code>0</code>, depending whatever just happened to be in memory at the time.
Simply because the <code>if</code> statement read an uninitialized value and then branched on the result.
The C Standard (6.7.8, paragraph 10<sup class="footnote-reference"><a href="#ISOC">2</a></sup>) states:</p>
<blockquote>
<p>If an object that has automatic storage duration is not initialized explicitly, its value is indeterminate.</p>
</blockquote>
<p>In the context of the C standard, &quot;indeterminate&quot; means a variable can either:</p>
<ul>
<li>
<p>Take on any legal value for the type (e.g. &quot;unspecified value&quot;).</p>
</li>
<li>
<p>Take on a value that doesn't represent any instance of the type (e.g.&quot;trap representation&quot;). UB ensues.</p>
</li>
</ul>
<p>Neither case bodes well for program reliability.
This simple function violates a MISRA C rule that explicitly targets this part of the standard:</p>
<blockquote>
<p><strong>[AR, Rule 9.1]</strong> The value of an object shouldn't be read if it hasn't been written<sup class="footnote-reference"><a href="#MISRA_2012">5</a></sup></p>
</blockquote>
<p>By default <code>gcc</code> - a popular, open-source C compiler - will not warn about this serious error.
We have to remember to pass the <code>-Wall</code> flag to get the below warning, and even then the program will build and run:</p>
<pre><code class="language-ignore">undef.c: In function ‘undef_func’:
undef.c:5:8: warning: ‘uninit_var’ is used uninitialized in this function [-Wuninitialized]
    5 |     if (uninit_var &gt; 0) {
      |        ^
</code></pre>
<p>Unfortunately, remembering special compiler flags is not a general solution.
C has <em>hundreds</em> of possible undefined behaviors and the <em>vast majority</em> cannot be caught by compiler warnings.
Thus, these &quot;misbehaviors&quot; rapidly creep into codebases as they grow in complexity.</p>
<blockquote>
<p><strong>What's a real example of this problem? In a security context?</strong></p>
<p>CVE-2022-0847, aka &quot;Dirty Pipe&quot;, was a highly exploitable vulnerability affecting Linux kernel versions after 5.8 (patched in stable releases 5.16.11, 5.15.25 and 5.10.102.<sup class="footnote-reference"><a href="#DirtyPipe">6</a></sup>).
A code refactor caused a structure's field to be uninitialized, and the instance of UB wasn't caught by compiler warnings or testing.</p>
<p>The uninitialized field was the <code>flags</code> member of a kernel-space <code>pipe_buffer</code> data structure.
This is used by the kernel to set up &quot;pipes&quot;, an Inter-Process Communication (IPC) mechanism.</p>
<p>By performing a sequence of normal, unprivileged operations, an attacker could reliably control the in-memory value that would later be read (instead of being reset/initialized correctly) as a flag for page cache write permissions<sup class="footnote-reference"><a href="#DirtyPipe">6</a></sup>.</p>
<p>By abusing this ill-gotten permission to pipe into files, an attacker can overwrite small chunks of content in system files that should be read-only.
This can enable, among other things, changing the root password to escalate local privileges and then overwriting SSH key data used for remote access.</p>
<p>Effectively, an attacker can gain &quot;full control&quot; of a vulnerable system just by getting a user to execute an unprivileged program. All because of one uninitialized field!
Give the attacker an inch, they might take a mile.</p>
</blockquote>
<h2 id="lets-try-that-in-rust"><a class="header" href="#lets-try-that-in-rust">Let's try that in Rust</a></h2>
<p>Undefined behavior is still possible in Rust, if using <code>unsafe</code> keyword<sup class="footnote-reference"><a href="#UndefRust">7</a></sup>, but it's <em>almost eliminated</em> in the safe subset of Rust.
That's a major part of why the Rust language is so amenable to writing correct, reliable software.
Rust removes UB, nearly entirely, by default.</p>
<blockquote>
<p><strong>Why the &quot;almost eliminated&quot; and &quot;nearly entirely&quot; caveats?</strong></p>
<p>At the time of this writing, Rust does not yet have an <em>official</em> language standard or specification.
There's no Rust equivalent to C or C++'s ISO documents.
So it's difficult to make a definitive claim.</p>
<p>The Rust Reference contains a non-exhaustive list of behaviors considered undefined in Rust<sup class="footnote-reference"><a href="#UndefRust">7</a></sup>, all of which would require the <code>unsafe</code> keyword to introduce.
So there are likely only three potential sources of UB in Rust:</p>
<ul>
<li>
<p><code>unsafe</code> functions or blocks whose invariants aren't actually upheld (our fault). This includes FFI edge cases, like a foreign exception crossing the FFI boundary with an unsupported ABI.</p>
</li>
<li>
<p>Rare compiler bugs<sup class="footnote-reference"><a href="#RustcBug">8</a></sup> that threaten soundness (patched once discovered).</p>
</li>
<li>
<p>Platform-specific invariant violations, like executing a program compiled with support for specific CPU extensions on CPU variant that doesn't support them (deployment problem).</p>
</li>
</ul>
<p>In July of 2022, the Ferrocene Language Specification (FLS)<sup class="footnote-reference"><a href="#FLS">9</a></sup> was made public.
The specification supports Ferrocene, a commercial downstream of the Rust compiler qualified for certain safety-critical uses.
While this specification does not aim to document the entire Rust language and standard library, it currently enumerates 21 possible sources of UB in Rust programs<sup class="footnote-reference"><a href="#FLSUndef">10</a></sup>.</p>
<p>We'll use <code>miri</code><sup class="footnote-reference"><a href="#Miri">11</a></sup>, an experimental dynamic tool for detecting UB in Rust programs, in Chapter 12.</p>
</blockquote>
<p>To make Rust's benefits more visceral, let's port our buggy C program to Rust:</p>
<pre><code class="language-rust ignore">fn undef_func() -&gt; isize {
    let uninit_var: isize;
    if uninit_var &gt; 0 {
        return 1;
    } else {
        return 0;
    }
}

fn main() {
    println!(&quot;{}\n&quot;, undef_func());
}</code></pre>
<p>Running <code>cargo build</code> results in the following:</p>
<pre><code class="language-ignore">error[E0381]: use of possibly-uninitialized variable: `uninit_var`
 --&gt; src/main.rs:3:8
  |
3 |     if uninit_var &gt; 0 {
  |        ^^^^^^^^^^ use of possibly-uninitialized `uninit_var`

For more information about this error, try `rustc --explain E0381`.
</code></pre>
<p>The <code>gcc</code> warning was similar, but heeding it was entirely optional.
In Rust, this same mistake is a hard error - the program will not compile unless we address the issue.
In other words, all safe Rust programs obey the aforementioned MISRA C Rule 9.1.</p>
<p>More generally, successfully compiling a safe Rust project means UB is likely eliminated.
So obeying the below buys us a great deal of assurance:</p>
<blockquote>
<p><strong>[RR, Directive 2.1]</strong> The entire project should compile without error<sup class="footnote-reference"><a href="#MISRA_2012">5</a></sup></p>
</blockquote>
<h2 id="why-does-ub-even-exist"><a class="header" href="#why-does-ub-even-exist">Why does UB even exist?</a></h2>
<p>Let's assume it's desirable to have multiple compilers for a language, whether they be commercial or open-source.
Each compiler implementation may serve a different niche, offer unique features, or just experiment with promising ideas.
Just like we have multiple web browsers that all support the same standards and protocols (HTML, HTTP2, etc).</p>
<p>Thus, a singular language standard (like the ISO C standard<sup class="footnote-reference"><a href="#ISOC">2</a></sup> we've mentioned) needs to be applicable to any compiler implementation targeting any platform architecture.
This is akin to an interface design problem.
It entails designing failure modes, which is where UB comes in<sup class="footnote-reference"><a href="#CppUndef">12</a></sup> - it's one way to &quot;handle&quot; edge cases the standard won't, shouldn't, or can't impose a universal rule for.</p>
<p>So the standard draws a boundary: it defines an &quot;abstract machine&quot; general enough to represent a variety of underlying hardware.
This has the upside of giving compiler developers room to introduce platform-specific optimizations.
Which is one of the main jobs of a compiler: it repeatedly applies <em>rewrite rules</em> to generate efficient machine code.</p>
<p>An optimizing compiler assumes that input source code never introduces UB, per the language specification.
If this assumption is:</p>
<ul>
<li>
<p><strong>True</strong> (source is indeed UB-free) - rewrite rules replace existing code with new code that is both faster and <em>logically equivalent</em>.</p>
<ul>
<li>These rules often take advantage of the &quot;wiggle room&quot; an abstract specification provides to play with architecture-specific instruction and/or memory model semantics. Or remove checks that prove necessary<sup class="footnote-reference"><a href="#RalfUB">13</a></sup>.</li>
</ul>
</li>
<li>
<p><strong>False</strong> (source contains UB) - application of rewrite rules may lead to <em>logical contradiction</em>.</p>
<ul>
<li>If the UB present is &quot;triggered&quot;, results include incorrect code replacements and/or arbitrary runtime operations.</li>
</ul>
</li>
</ul>
<p>This dichotomy begs the question: couldn't a sufficiently &quot;smart&quot; compiler simply <em>verify</em> its assumption of UB-free source?
Just like it checks syntax and typing at compile time?</p>
<p>The answer is yes!
As alluded to, that's exactly what <code>rustc</code> does when compiling fully-safe Rust code<sup class="footnote-reference"><a href="#IntOverflow">14</a></sup>.
Using a combination of its advanced type system and runtime check insertion.</p>
<p>But guaranteeing absence of all UB automatically is technically infeasible for C, C++, <em>and</em> <code>unsafe</code> Rust.
Futhermore, even the safest of Rust programs might link against <em>some</em> <code>unsafe</code> code internally, like C's <code>libc</code> or parts of Rust's <code>core</code><sup class="footnote-reference"><a href="#Core">15</a></sup>.
From an assurance perspective, we're betting that such widely-used and well-vetted dependencies are less likely to contain UB than <code>unsafe</code> code we'd write ourselves.</p>
<blockquote>
<p><strong>What's an example of an optimization?</strong></p>
<p>John Regehr presented a compelling snippet in a 2017 talk<sup class="footnote-reference"><a href="#CppUndef">12</a></sup>, we'll adapt it here.
Say we have this function:</p>
<pre><code class="language-c">int set(int* a, int* b) {
   *b = 3;
   *a = 7;
   return *b;
}
</code></pre>
<p><code>a</code> and <code>b</code> are pointers to the same type, <code>int</code>, and they may alias (recall our discussion of pointers and aliasing from Chapter 2).
That means the function should return <code>3</code> if the pointers don't alias or <code>7</code> if they do.</p>
<p>Thus, the compiler is forced to generate machine code that <em>loads from memory</em> before returning an integer.
It needs to read the freshest data to handle both the alias and no-alias cases.
Something akin to the following snippet of x86-64 assembly may be emitted (ATT syntax):</p>
<pre><code class="language-assembly">set:
  movl $3, (%rsi)
  movl $7, (%rdi)
  movl (%rsi), %eax
</code></pre>
<p>If you're not familiar with x86 assembly, the key idea here is that the last line is a load from a memory address:</p>
<ul>
<li>
<p><code>%rsi</code> is a register holding a pointer.</p>
</li>
<li>
<p><code>(%rsi)</code> is a dereference of the pointer, we read the data it points to.</p>
</li>
<li>
<p><code>movl (%rsi), %eax</code> copies the data read into <code>%eax</code>, the register used for return values<sup class="footnote-reference"><a href="#EAX">16</a></sup>.</p>
</li>
</ul>
<p>Now say the two parameters are pointers to different integer types:</p>
<pre><code class="language-c">int set(long* a, int* b) {
   *b = 3;
   *a = 7;
   return *b;
}
</code></pre>
<p>In this case the compiler can, per the C standard's definition of &quot;strict aliasing&quot;, assume that the pointers don't alias.
We no longer need to read a current value from memory, we can return a constant <code>3</code>.
That's faster.
This optimization may result in assembly like:</p>
<pre><code class="language-assembly">set:
  movl $3, (%rsi)
  movq $7, (%rdi)
  movl $3, %eax
</code></pre>
<p>Great, we got more efficient code.
There's no read in the last instruction, just a move of constant.</p>
<p>So what's the problem?
A C programmer can break that assumption by casting an <code>int*</code> to a <code>long*</code> before calling the function.
Behavior of the below program is undefined:</p>
<pre><code class="language-c">include &lt;stdio.h&gt;

int set(long* a, int* b) {
    *b = 3;
    *a = 7;
    return *b;
}

int main() {
    int x = 0;
    printf(&quot;%d\n&quot;, set((long*)&amp;x, &amp;x));
}
</code></pre>
<p>For various reasons, casting is a common operation in C and C++ programs.
Projects like the Linux kernel explicitly disable this specific optimization for safety<sup class="footnote-reference"><a href="#UndefResearch">4</a></sup>.</p>
<p>In safe Rust, we can't cast references. And we're able to guarantee absence of mutable aliasing at all times.
So, in this particular case, Rust is capable of performing the optimization without the UB danger.</p>
</blockquote>
<h2 id="what-are-the-consequences-of-ub-in-practice"><a class="header" href="#what-are-the-consequences-of-ub-in-practice">What are the consequences of UB in practice?</a></h2>
<p>There are four possible outcomes<sup class="footnote-reference"><a href="#CppUndef">12</a></sup>.
We can enumerate them, roughly in order of best to worst case:</p>
<ol>
<li>
<p><strong>Program breaks immediately:</strong> Crash (e.g. segmentation fault) or exception (e.g. attempt to divide by zero) will be hit at runtime, the program will halt .</p>
<ul>
<li>The easiest case to detect prior to shipping a product. We just need to execute the faulty code path once, in a dynamic test.</li>
</ul>
</li>
<li>
<p><strong>Program continues with corrupted state:</strong> Internal state becomes logically invalid, but the program continues to execute. It may crash at a later point in time, if some arbitrary condition is met, or simply finish but produce the wrong result.</p>
<ul>
<li>This case is more challenging to detect, it can require more thorough test cases to uncover.</li>
</ul>
</li>
<li>
<p><strong>Program works as expected, despite relying on UB:</strong> The program appears correct from a testing perspective, but the UB is a &quot;time bomb&quot; waiting to trigger. The program may no longer work compiled for a different architecture, with a newer compiler, or simply using different settings.</p>
<ul>
<li>Detection requires a change or update of the build toolchain. And, if the UB manifests as case 2 above, detection may not be immediate.</li>
</ul>
</li>
<li>
<p><strong>Program is vulnerable to attack:</strong> The program doesn't trigger UB given expected inputs, but will if an attacker provides a specially-crafted input. Exploiting memory corruption bugs entails triggering UB (we'll see next chapter).</p>
<ul>
<li>This is the worst case scenario - an attacker detects UB our tests failed to catch, and then leverages it to compromise production assets.</li>
</ul>
</li>
</ol>
<p>The first three potential consequences of UB are a threat to functionality and reliability.
The fourth is a threat to security.
That's why the MISRA C standard includes this broad rule:</p>
<blockquote>
<p><strong>[AR, Rule 1.3]</strong> Eliminate all occurrences of undefined behavior<sup class="footnote-reference"><a href="#MISRA_2012">5</a></sup></p>
</blockquote>
<p>Rust's design generally makes it easier to comply with the rule.
The developer isn't responsible for remembering hundreds of obscure UB edge cases simultaneously, and then enforcing them without fail across a million-line codebase.
Instead, the Rust compiler checks for potential issues.
Automatically and accurately.</p>
<h2 id="takeaway"><a class="header" href="#takeaway">Takeaway</a></h2>
<p>Our best tools can't pinpoint every Undefined Behavior in a moderately-sized C or C++ codebase.</p>
<ul>
<li>
<p>Commercial static analysis tools suffer from false positives: actionable results are often buried in noise. Moreover, a lot of UB is difficult to design a detection algorithm for. As you may recall from Chapter 2, important problems in static analysis, like aliasing, are mathematically undecidable.</p>
</li>
<li>
<p>Dynamic tools (like LLVM's open-source <code>UBSan</code><sup class="footnote-reference"><a href="#UBSan">17</a></sup>, <code>ASan</code><sup class="footnote-reference"><a href="#ASan">18</a></sup>, and <code>TSan</code><sup class="footnote-reference"><a href="#TSan">19</a></sup>) have improved greatly in recent years, but still miss bugs due to fundamental limitations of dynamic testing (tiny sample of program state-space). Even when combined with coverage-guided fuzzing (introduced in Chapter 12).</p>
</li>
</ul>
<p>That's a part of why standards like MISRA C exist, and why countless engineering hours are devoted to ensuring these standards are followed.</p>
<p>Reducing defect rate is an uphill battle.
One could make the argument that, due to the vast amount of Undefined Behavior C and C++ allow for in their respective standards, it's a war of attrition.
Winners pay an incredible engineering cost - in tool licensing, processes that slow shipping, and debugging person-hours.
Or in service disruption, should the UB lead to an exploitable vulnerability.</p>
<p>So let's start learning that safe subset of Rust!
Rust isn't perfect, but eliminating UB is certainly its strong suit.</p>
<blockquote>
<p><strong><code>gcc</code> hasn't surrendered the fight!</strong></p>
<p>Given a weak type system and a high-UB written specification, we believe that C compilers have low assurance ceilings with respect to memory safety<sup class="footnote-reference"><a href="#CompilerAssurance">20</a></sup>.
But important advances are still being made.
And, given C's widespread usage, every inch of progress is high-impact.</p>
<p><code>gcc</code> 12 offers improved, experimental, static taint analysis<sup class="footnote-reference"><a href="#GCC">21</a></sup> (flow tracking for untrusted data).
In conjunction with source annotations, that's a way to systematically review potential attack entry points.
And an advanced feature not currently offered by <code>rustc</code>.</p>
<p>This same version adds a new <code>-Wanalyzer-use-of-uninitialized-value</code> flag<sup class="footnote-reference"><a href="#GCC">21</a></sup>.
Unlike the <code>-Wuninitialized</code> warning our above use of <code>-Wall</code> encapsulated, this new flag uses branch-sensitive static analysis of flows between functions.
That may mean less false positives <em>and</em> more actionable warnings.</p>
<p>We did not test <code>gcc</code> 12's ability to detect the aforementioned &quot;Dirty Pipe&quot;<sup class="footnote-reference"><a href="#DirtyPipe">6</a></sup> kernel vulnerability.
But that could be a worthwhile exercise for interested readers.</p>
</blockquote>
<hr />
<div class="footnote-definition" id="MISRA_TALK"><sup class="footnote-definition-label">1</sup>
<p><a href="https://www.youtube.com/watch?v=LCZotsYizRI"><em>The Misra C Coding Standard and its Role in the Development (SAS Talk)</em></a>. Roberto Bagnara (2018).</p>
</div>
<div class="footnote-definition" id="ISOC"><sup class="footnote-definition-label">2</sup>
<p><a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf"><em>ISO/IEC 9899:TC3</em></a>. International Organization for Standardization (2007). Note newer standards for the C language must be paid for, they are not freely available online. The points we make in this book are still applicable to newer C standards.</p>
</div>
<div class="footnote-definition" id="NasalDemons"><sup class="footnote-definition-label">3</sup>
<p><a href="http://www.catb.org/jargon/html/N/nasal-demons.html"><em>nasal demons</em></a>. According to an infamous Usenet post, the arbitrary consequences of UB could include making &quot;demons fly out of your nose&quot;. Hence UB is sometimes joking referred to as &quot;nasal demons&quot;.</p>
</div>
<div class="footnote-definition" id="UndefResearch"><sup class="footnote-definition-label">4</sup>
<p><a href="https://people.csail.mit.edu/nickolai/papers/wang-undef-2012-08-21.pdf"><em>Undefined Behavior: What Happened to My Code?</em></a>. Xi Wang, Haogang Chen, Alvin Cheung, Zhihao Jia, Nickolai Zeldovich, M. Frans Kaashoek (2012).</p>
</div>
<div class="footnote-definition" id="MISRA_2012"><sup class="footnote-definition-label">5</sup>
<p><em>MISRA C: 2012 Guidelines for the use of the C language in critical systems (3rd edition)</em>. MISRA (2019).</p>
</div>
<div class="footnote-definition" id="DirtyPipe"><sup class="footnote-definition-label">6</sup>
<p><a href="https://dirtypipe.cm4all.com/"><em>The Dirty Pipe Vulnerability</em></a>. Max Kellerman (2022).</p>
</div>
<div class="footnote-definition" id="UndefRust"><sup class="footnote-definition-label">7</sup>
<p><a href="https://doc.rust-lang.org/reference/behavior-considered-undefined.html"><em>Behavior considered undefined</em></a>. The Rust Reference (Accessed 2022).</p>
</div>
<div class="footnote-definition" id="RustcBug"><sup class="footnote-definition-label">8</sup>
<p><a href="https://internals.rust-lang.org/t/unsoundness-in-pin/11311">Unsoundness in <code>Pin</code></a>. comex (2019).</p>
</div>
<div class="footnote-definition" id="Miri"><sup class="footnote-definition-label">11</sup>
<p><a href="https://github.com/rust-lang/miri"><em><code>miri</code></em></a>. Ralf Jung (Accessed 2022).</p>
</div>
<div class="footnote-definition" id="FLS"><sup class="footnote-definition-label">9</sup>
<p><a href="https://spec.ferrocene.dev/index.html"><em>Ferrocene Language Specification</em></a>. Ferrous Systems (2022).</p>
</div>
<div class="footnote-definition" id="FLSUndef"><sup class="footnote-definition-label">10</sup>
<p><a href="https://spec.ferrocene.dev/undefined-behavior.html"><em>List of undefined behavior</em></a>. Ferrous Systems (2023).</p>
</div>
<div class="footnote-definition" id="Ferrocene"><sup class="footnote-definition-label">22</sup>
<p><a href="https://github.com/ferrocene/ferrocene"><code>ferrocene</code></a>. Ferrous Systems (2023).</p>
</div>
<div class="footnote-definition" id="CppUndef"><sup class="footnote-definition-label">12</sup>
<p><a href="https://www.youtube.com/watch?v=v1COuU2vU_w"><em>CppCon 2017: &quot;Undefined Behavior in 2017&quot;</em></a>. John Regehr (2017).</p>
</div>
<div class="footnote-definition" id="RalfUB"><sup class="footnote-definition-label">13</sup>
<p><a href="https://www.ralfj.de/blog/2021/11/18/ub-good-idea.html"><em>Undefined Behavior deserves a better reputation</em></a>. Ralf Jung (2021).</p>
</div>
<div class="footnote-definition" id="IntOverflow"><sup class="footnote-definition-label">14</sup>
<p>This claim may have debatable edge cases. For example, if <code>overflow-checks = false</code> is specified in <code>Cargo.toml</code> (the default setting for the optimized <code>release</code> profile) then integer overflow can happen at runtime. That's not technically UB in Rust, like it is in C/C++, because you can reliably expect two's complement wrap. But it might still cause unanticipated bugs in the context of your larger application.</p>
</div>
<div class="footnote-definition" id="Core"><sup class="footnote-definition-label">15</sup>
<p><a href="https://doc.rust-lang.org/core/"><em>The Rust Core Library</em></a>. The Rust Team (Accessed 2022).</p>
</div>
<div class="footnote-definition" id="EAX"><sup class="footnote-definition-label">16</sup>
<p>Technically, <code>%eax</code> is the lower 4 bytes of the 8-byte <code>%rax</code> register on an x86-64 system. <code>%rax</code> is used for return values. In this example, we're dereferencing 8-byte pointers but returning a 4-byte integer.</p>
</div>
<div class="footnote-definition" id="UBSan"><sup class="footnote-definition-label">17</sup>
<p><a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html"><em>UndefinedBehaviorSanitizer</em></a>. LLVM Project (Accessed 2022).</p>
</div>
<div class="footnote-definition" id="ASan"><sup class="footnote-definition-label">18</sup>
<p><a href="https://clang.llvm.org/docs/AddressSanitizer.html"><em>AddressSanitizer</em></a>. LLVM Project (Accessed 2022).</p>
</div>
<div class="footnote-definition" id="TSan"><sup class="footnote-definition-label">19</sup>
<p><a href="https://clang.llvm.org/docs/ThreadSanitizer.html"><em>ThreadSanitizer</em></a>. LLVM Project (Accessed 2022).</p>
</div>
<div class="footnote-definition" id="CompilerAssurance"><sup class="footnote-definition-label">20</sup>
<p>On the other hand, C compilers are mature and well-understood from a safety qualification perspective. And further ahead in formal verification. As an example, the CompCert<sup class="footnote-reference"><a href="#CompCert">23</a></sup> C compiler proves that source code semantics match machine code semantics. No current Rust compiler can claim that level or kind of assurance.</p>
</div>
<div class="footnote-definition" id="GCC"><sup class="footnote-definition-label">21</sup>
<p><a href="https://developers.redhat.com/articles/2022/04/12/state-static-analysis-gcc-12-compiler"><em>The state of static analysis in the GCC 12 compiler</em></a>. David Malcom (2022).</p>
</div>
<div class="footnote-definition" id="CompCert"><sup class="footnote-definition-label">23</sup>
<p><a href="https://compcert.org/"><em>CompCert</em></a>. Xavier Leroy (Accessed 2022).</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chp3/_index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chp3/rust_1_low_data_rep.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chp3/_index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chp3/rust_1_low_data_rep.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
