<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust: Ownership in Practice (5/6) - High Assurance Rust: Developing Secure and Robust Software</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../landing.html">High Assurance Rust</a></li><li class="chapter-item expanded affix "><a href="../faq.html">Frequently Asked Questions (FAQ)</a></li><li class="chapter-item expanded affix "><a href="../engage.html">Engage with this Book!</a></li><li class="chapter-item expanded affix "><a href="../cfp.html">Sponsor Call for Proposals (CFP)</a></li><li class="chapter-item expanded affix "><a href="../download.html">Download</a></li><li class="chapter-item expanded affix "><a href="../changelog.html">Changelog</a></li><li class="chapter-item expanded affix "><a href="../license.html">License</a></li><li class="chapter-item expanded affix "><li class="part-title">Novice: Systems Security</li><li class="spacer"></li><li class="chapter-item expanded "><a href="../chp1/_index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chp1/why_this_book.html"><strong aria-hidden="true">1.1.</strong> Why this book?</a></li><li class="chapter-item expanded "><a href="../chp1/how_is_this_book_structured.html"><strong aria-hidden="true">1.2.</strong> How is this book structured?</a></li><li class="chapter-item expanded "><a href="../chp1/challenges.html"><strong aria-hidden="true">1.3.</strong> Hands-on Learning</a></li><li class="chapter-item expanded "><a href="../chp1/about_the_team.html"><strong aria-hidden="true">1.4.</strong> About the Team</a></li><li class="chapter-item expanded "><a href="../chp1/_hands_on.html"><strong aria-hidden="true">1.5.</strong> Warmup: Environment Setup</a></li></ol></li><li class="chapter-item expanded "><a href="../chp2/_index.html"><strong aria-hidden="true">2.</strong> Software Assurance</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chp2/static_vs_dynamic.html"><strong aria-hidden="true">2.1.</strong> Static vs. Dynamic Tools</a></li><li class="chapter-item expanded "><a href="../chp2/static_assurance_1.html"><strong aria-hidden="true">2.2.</strong> Static Assurance (1/2)</a></li><li class="chapter-item expanded "><a href="../chp2/static_assurance_2.html"><strong aria-hidden="true">2.3.</strong> Static Assurance (2/2)</a></li><li class="chapter-item expanded "><a href="../chp2/dynamic_assurance_1.html"><strong aria-hidden="true">2.4.</strong> Dynamic Assurance (1/3)</a></li><li class="chapter-item expanded "><a href="../chp2/dynamic_assurance_2.html"><strong aria-hidden="true">2.5.</strong> Dynamic Assurance (2/3)</a></li><li class="chapter-item expanded "><a href="../chp2/dynamic_assurance_3.html"><strong aria-hidden="true">2.6.</strong> Dynamic Assurance (3/3)</a></li><li class="chapter-item expanded "><a href="../chp2/limits.html"><strong aria-hidden="true">2.7.</strong> Limitations and Threat Modeling</a></li><li class="chapter-item expanded "><a href="../chp2/cli.html"><strong aria-hidden="true">2.8.</strong> DIY CLI Encryption Tool</a></li><li class="chapter-item expanded "><a href="../chp2/operational_assurance_1.html"><strong aria-hidden="true">2.9.</strong> Operational Assurance (1/2)</a></li><li class="chapter-item expanded "><a href="../chp2/operational_assurance_2.html"><strong aria-hidden="true">2.10.</strong> Operational Assurance (2/2)</a></li><li class="chapter-item expanded "><a href="../chp2/_hands_on.html"><strong aria-hidden="true">2.11.</strong> Challenge: Extend the CLI Tool</a></li></ol></li><li class="chapter-item expanded "><a href="../chp3/_index.html"><strong aria-hidden="true">3.</strong> Rust Zero-Crash Course</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chp3/undef.html"><strong aria-hidden="true">3.1.</strong> On Undefined Behavior</a></li><li class="chapter-item expanded "><a href="../chp3/rust_1_low_data_rep.html"><strong aria-hidden="true">3.2.</strong> Rust: Low-Level Data (1/6)</a></li><li class="chapter-item expanded "><a href="../chp3/rust_2_high_data_rep.html"><strong aria-hidden="true">3.3.</strong> Rust: High-Level Data (2/6)</a></li><li class="chapter-item expanded "><a href="../chp3/rust_3_ctrl_flow.html"><strong aria-hidden="true">3.4.</strong> Rust: Control Flow (3/6)</a></li><li class="chapter-item expanded "><a href="../chp3/rust_4_own_1.html"><strong aria-hidden="true">3.5.</strong> Rust: Ownership Principles (4/6)</a></li><li class="chapter-item expanded "><a href="../chp3/rust_5_own_2.html" class="active"><strong aria-hidden="true">3.6.</strong> Rust: Ownership in Practice (5/6)</a></li><li class="chapter-item expanded "><a href="../chp3/rust_6_error.html"><strong aria-hidden="true">3.7.</strong> Rust: Error Handling (6/6)</a></li><li class="chapter-item expanded "><a href="../chp3/modules.html"><strong aria-hidden="true">3.8.</strong> The Module System</a></li><li class="chapter-item expanded "><a href="../chp3/tooling.html"><strong aria-hidden="true">3.9.</strong> Recommended Tooling</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.10.</strong> Rust's Release Cycle</div></li><li class="chapter-item expanded "><a href="../chp3/_hands_on.html"><strong aria-hidden="true">3.11.</strong> Challenge: Port a Program</a></li></ol></li><li class="chapter-item expanded "><a href="../chp4/_index.html"><strong aria-hidden="true">4.</strong> Understanding Memory</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> A Software Perspective</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> An Attacker's Perspective</div></li><li class="chapter-item expanded "><a href="../chp4/safe_rust_PLACEHOLDER.html"><strong aria-hidden="true">4.3.</strong> Rust's Memory Safety Guarantees</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> Integer Representation Issues</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> The #![no_std] Attribute</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.6.</strong> Case Study: Real-world Rust CVEs</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.7.</strong> Debugging with Mozilla rr</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.8.</strong> Writing an Exploit</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.9.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Advanced Beginner: Core Project</li><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Binary Search Tree (BST) Basics</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Core BST Operations in Python</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> Problems Translating to Rust</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> The Importance of Balance</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Building an Arena Allocator</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Let's Talk Allocators</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> A Stack-Only Arena</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Index-based Data Structures</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> A Self-balancing BST</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chp7/traits.html"><strong aria-hidden="true">7.1.</strong> Interface-relevant Traits</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.2.</strong> Scapegoat Trees</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.</strong> Insert</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.</strong> Remove</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.5.</strong> Find</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.6.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Digital Twin Testing</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> Basic QEMU Internals</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> How Semi-hosting Works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> CLI REPL Harness</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.4.</strong> Limitations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.5.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.6.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Building Maps and Sets</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Implementing Iterators</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">10.1.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.2.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Competent: Validation and Deployment</li><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Static Verification</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">11.1.</strong> An Introduction to 1st Order Logic</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.2.</strong> Proving Absence of Panics</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.3.</strong> Deductively Verifying our Arena Allocator</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.4.</strong> Model Checking for unsafe Code</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.5.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.6.</strong> Challenge: Prove a Sorting Algorithm</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Dynamic Testing</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">12.1.</strong> Introduction to Coverage-Guided Fuzzing</div></li><li class="chapter-item expanded "><a href="../chp12/diff_fuzz_PLACEHOLDER.html"><strong aria-hidden="true">12.2.</strong> Building a Differential Fuzzing Harness</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.3.</strong> Using Miri to Detect Undefined Behavior</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.4.</strong> Benchmarking and Optimization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.5.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.6.</strong> Challenge: Bug-hunting with Fuzzers</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Operational Deployment</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">13.1.</strong> Understanding unsafe (1/3)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.2.</strong> Understanding unsafe (2/3)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.3.</strong> Understanding unsafe (3/3)</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.4.</strong> CFFI 101</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.5.</strong> C99 Interoperability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.6.</strong> Python3 Interoperability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.7.</strong> Runtime Balance Reconfiguration</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.8.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.9.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Maximizing Assurance</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">14.1.</strong> Rust Security Research</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.2.</strong> Rust's Limitations</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.3.</strong> Best Practices Beyond Rust</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.4.</strong> TODO</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.5.</strong> Challenge: TODO</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Conclusion</li><li class="spacer"></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Review</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">15.1.</strong> Key Concepts</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.2.</strong> Key Blue-Team Skills</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.3.</strong> Key Red-Team Skills</div></li></ol></li><li class="chapter-item expanded "><a href="../chp16_appendix/_index.html"><strong aria-hidden="true">16.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">16.1.</strong> Setup: Using our Docker Container</div></li><li class="chapter-item expanded "><a href="../chp16_appendix/tools.html"><strong aria-hidden="true">16.2.</strong> Inventory: Tools of the Trade</a></li><li class="chapter-item expanded "><a href="../chp16_appendix/books.html"><strong aria-hidden="true">16.3.</strong> Inventory: Recommended Reading</a></li><li class="chapter-item expanded "><a href="../chp16_appendix/resources.html"><strong aria-hidden="true">16.4.</strong> Inventory: Additional Resources</a></li><li class="chapter-item expanded "><a href="../chp16_appendix/crypto.html"><strong aria-hidden="true">16.5.</strong> Fundamentals: Stream Ciphers</a></li><li class="chapter-item expanded "><a href="../chp16_appendix/types.html"><strong aria-hidden="true">16.6.</strong> Fundamentals: Type Systems</a></li><li class="chapter-item expanded "><a href="../chp16_appendix/components.html"><strong aria-hidden="true">16.7.</strong> Fundamentals: Component-Based Design</a></li><li class="chapter-item expanded "><a href="../chp16_appendix/mem_hierarch.html"><strong aria-hidden="true">16.8.</strong> Fundamentals: Memory Hierarchy</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.9.</strong> Fundamentals: Dynamic Linking</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.10.</strong> Misc: Size Optimization</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.11.</strong> Misc: The Typestate Pattern</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.12.</strong> Misc: C++ Interoperability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.13.</strong> Misc: Compile-time Metaprogramming</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">High Assurance Rust: Developing Secure and Robust Software</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/tnballo/high-assurance-rust" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://highassurance.rs/engage.html#submit-feedback-questions-issues-or-prs" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-ownership-in-practice-5-of-6"><a class="header" href="#rust-ownership-in-practice-5-of-6">Rust: Ownership in Practice (5 of 6)</a></h1>
<p>Rust offers four mechanisms to make ownership flexible and practical.
Ways for ownership to ebb and flow throughout a program while still upholding the foundational principles.</p>
<p>We've already seen two of the ways, moving and borrowing, but a survey of the whole gambit is well-warranted.
These are the &quot;tricks&quot; for working with the <strong>borrow checker</strong> - the compiler component<sup class="footnote-reference"><a href="#BorrowChecker">1</a></sup> responsible for implementing and enforcing ownership.</p>
<p>Appeasing it can be challenging.
Programmers new to Rust may experience &quot;fighting the borrow checker&quot;: running into errors when trying to express a program.
Fortunately, those roadblocks largely disappear with experience.</p>
<p>In this section, we'll continue our discussion of ownership by:</p>
<ul>
<li>Motivating the challenge from a new perspective.</li>
<li>Illustrating lifetimes, with ASCII visualizations.</li>
<li>Enumerating all four mechanisms for working with the borrow checker.</li>
</ul>
<h2 id="keep-the-assurance-goal-in-mind"><a class="header" href="#keep-the-assurance-goal-in-mind">Keep the Assurance Goal in Mind</a></h2>
<p>Before heading back down into code snippets, let's reiterate our motivation.
Why are these complex ownership concepts worth learning, again?</p>
<p>You could argue the Rust compiler is akin to a human-in-the-loop property verification engine.
A meld of machine and man.
That's a grandiose conceptualization.
But there's some truth to it<sup class="footnote-reference"><a href="#GeneralTrend">2</a></sup>.</p>
<ul>
<li>
<p><strong>Benefit:</strong> The machine runs analyses to guarantee memory safety under performance constraints (the property proven).</p>
</li>
<li>
<p><strong>Trade-off for partial automation:</strong> The human maintains lifetime source annotations to help out when the machine gets stuck. Or, sometimes, reframes the problem entirely to make it machine-checkable.</p>
<ul>
<li><strong>Compiler error feedback loop:</strong> Rust's compile-time errors are often highly actionable. But they're also complex and can be frequent. It's an imperfect feedback channel.</li>
</ul>
</li>
</ul>
<p>The collaboration, when successful, is fruitful.
We get performant programs free of memory safety vulnerabilities and emphasizing general reliability (e.g. strict error handling).
That's a solid starting point for high assurance software.</p>
<blockquote>
<p><strong>Computers and Humans Exploring Software Security (CHESS)</strong></p>
<p>CHESS was  DARPA research program<sup class="footnote-reference"><a href="#CHESS">3</a></sup> on &quot;the effectiveness of enabling computers and humans to collaboratively reason over software artifacts...with the goal of finding 0-day vulnerabilities at a scale and speed appropriate for the complex software ecosystem upon which the U.S. Government, military, and economy depend&quot;<sup class="footnote-reference"><a href="#CHESSDesc">4</a></sup>.</p>
<p>It's a response to the fact that in-depth security assessments are a <strong>difficult to scale expert process</strong>.
Rust was not considered a solution under the CHESS program.
It wouldn't have met all criteria.
But we can think of it as a <strong>shift left</strong> in the lifecycle: developers aided by the borrow checker don't introduce memory corruption bugs for assessors to find.</p>
<p>From that perspective, Rust has an incredible <strong>Return On Investment (ROI)</strong>.
The bugs Rust prevents early would be more expensive to fix later in an asset's lifecycle:</p>
<ul>
<li>Patching production has per-customer cost and risk.</li>
<li>Heeding a compiler error does not.</li>
</ul>
</blockquote>
<h2 id="scope-vs-lifetime"><a class="header" href="#scope-vs-lifetime">Scope vs. Lifetime</a></h2>
<p>As alluded to before, scope and lifetime are distinct concepts in most programming languages:</p>
<ul>
<li>
<p><strong>Scope</strong> is the <em>section(s) of code</em> where a value is accessible.</p>
<ul>
<li>Unless the value is global, that typically means between within a function - between <code>{</code> and <code>}</code> brackets in many languages.</li>
</ul>
</li>
<li>
<p><strong>Lifetime</strong> is the <em>duration</em> of time during which a value is in a valid state.</p>
<ul>
<li>In garbage collected languages, that's as long as a reference to the value exists. In systems languages, that may be until a value is de-allocated.</li>
</ul>
</li>
</ul>
<p>Rust's borrow checker blurs the line between these two concepts.
It has a relentless obsession with scope-based lifetime enforcement.</p>
<p>Let's get a feel for these ideas pan out with an example <em>borrowed from other sources</em><sup class="footnote-reference"><a href="#ExampleCredit">5</a></sup> (pun intended).
We'll start with a tiny snippet of C++ code:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;

int main() {
    int *p; // Pointer to an integer

    { // Start of scope S
        int x = 1337;   // Value
        p = &amp;x;         // Reference to value
    } // End of scope S

    // Printing x triggers undefined behavior! :(
    std::cout &lt;&lt; &quot;x = &quot; &lt;&lt; *p &lt;&lt; std::endl;
    return 0;
}
</code></pre>
<p>C++ doesn't have a borrow checker, so this program will compile without warnings<sup class="footnote-reference"><a href="#Gpp">6</a></sup>.
And the print at the end of this function (the line starting with <code>std::cout</code>) triggers UB.
In the context of a larger program, any UB may lead to a crash or an exploit.</p>
<p>The problem is that we're attempting to use a reference (<code>p</code>) to a value (<code>x</code>) that has gone out-of-scope.
<code>x</code>'s lifetime is over at the time of the print.
Let's see what the borrow checker has to say, when we try that in Rust:</p>
<pre><code class="language-rust ignore">fn main() {
    let p; // Reference to an integer

    { // Start of scope S
        let x = 1337;   // Value
        p = &amp;x;         // Reference to value
    } // End of scope S

    // Compile-time error!
    println!(&quot;x = {}&quot;, p);
}
</code></pre>
<p>It emits this error:</p>
<pre><code class="language-ignore">error[E0597]: `x` does not live long enough
  --&gt; src/main.rs:6:13
   |
6  |         p = &amp;x;         // Reference to value
   |             ^^ borrowed value does not live long enough
7  |     } // End of scope S
   |     - `x` dropped here while still borrowed
...
10 |     println!(&quot;x = {}&quot;, p);
   |                        - borrow later used here
</code></pre>
<p>Take a second to read through this compiler error.
For some readers, this may be the point at which a complex compiler error is starting to make some sense.
The borrow checker is complaining about a lifetime problem.
Rightfully so.
We can draw out the two lifetimes at play (<code>'a</code> and <code>'b</code>):</p>
<pre><code class="language-rust ignore">fn main() {
    let p;                  // ---------+-- 'a
                            //          |
    {                       //          |
        let x = 1337;       // -+-- 'b  |
        p = &amp;x;             //  |       |
    }                       // -+       |
                            //          |
    println!(&quot;x = {}&quot;, p);  // ---------+
}
</code></pre>
<p>Recall that borrows cannot out-live the referenced value.
Because <code>'a</code> outlives <code>'b</code> in the above, the borrow checker rightfully rejects this program.
Neither C++ or Rust would have this issue without that nested scope <code>S</code> encapsulating <code>x</code>'s definition.
This is fine:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let p;                  // ---------+-- 'a
                            //          |
    let x = 1337;           // -+-- 'b  |
    p = &amp;x;                 //  |       |
                            //  |       |
    println!(&quot;x = {}&quot;, p);  // -+-------+
}
</code></pre></pre>
<p>Here, the borrow's lifetime (<code>'b</code>) is a strict subset of the borrowed value's lifetime (<code>'a</code>).
No rules have been violated.</p>
<p>Now nested scopes within functions aren't terribly common, so this example may feel contrived.
Fair enough.
It only serves to illustrate the concept.
More realistic examples might include returning references to stack locals, freeing a variable twice, reading a freed value, etc.
Like those nesting brackets in our example, these cases can create lifetime mismatches.</p>
<p>Once a code base grows in size and complexity, lifetimes become difficult to reason about manually.
And even a single mistake could jeopardize reliability, security, or both.</p>
<h2 id="flexibility-mechanisms"><a class="header" href="#flexibility-mechanisms">Flexibility Mechanisms</a></h2>
<p>In order for ownership to be compatible with shipping real-world programs, we need a little leeway.
Some wiggle room within the single-owner rule.
We'll overview these flexibility mechanisms now, and use them throughout the book.</p>
<h3 id="1-moving-ownership"><a class="header" href="#1-moving-ownership">1) Moving ownership</a></h3>
<p>We saw moving in the prior section.
Now that we have a better understanding of lifetimes, let's review that first <code>Proc</code> tree example from the previous section - the one where we used moves instead of borrowing.</p>
<p>The below right-hand ASCII graph shows how the lifetime for each variable ends when it's value is moved into another variable:</p>
<pre><code class="language-rust ignore">// Alloc bash                                                       //
let bash = Proc::new(&quot;bash&quot;, State::Running, Vec::new());           // ---------+-- 'a
                                                                    //          |
// Alloc rsyslogd, 1st move: bash -&gt; rsyslogd                       //          |
let rsyslogd = Proc::new(&quot;rsyslogd&quot;, State::Running, vec![bash]);   // ---------+-- 'b
                                                                    //          |
// Alloc cron                                                       //          |
let cron = Proc::new(&quot;cron&quot;, State::Sleeping, Vec::new());          // -+-- 'c  |
                                                                    //  |       |
// Alloc init, 2nd and 3rd moves: cron -&gt; init, rsyslogd -&gt; init    //  |       |
let init = Proc::new(&quot;init&quot;, State::Running, vec![cron, rsyslogd]); // -+-------+--'d
                                                                    //          |
// Print serialized tree to see ownership hierarchy                 //          |
dbg!(init);                                                         // ---------+
</code></pre>
<p>In general, ownership can be moved via:</p>
<ul>
<li>Assigning a value to a new variable.</li>
<li>Passing a value into a function (if not using a reference).</li>
<li>Returning a value from a function.</li>
</ul>
<h3 id="2-duplicating-data-for-types-that-implement-the-copy-trait"><a class="header" href="#2-duplicating-data-for-types-that-implement-the-copy-trait">2) Duplicating data for types that implement the <code>Copy</code> trait</a></h3>
<p>We've covered moving for strings and the <code>Proc</code> struct - types with the potential to own a lot of data:</p>
<ul>
<li>
<p>A string might be very long, maybe it contains the contents of an entire file.</p>
</li>
<li>
<p>A <code>Proc</code> instance might have hundreds of children, direct and/or nested.</p>
</li>
</ul>
<p>Moving makes the assignment operator, <code>=</code>, efficient in such cases - sizable data isn't copied when ownership is transferred.
We just duplicate a known-valid pointer.</p>
<p>But for some types, like integers and characters, moving is overkill.
The data these types hold is so small it's trivial to perform a copy - it just means duplicating a short sequence of bits.
There's no resources to free later, a perfect replica can be cheaply created.
We can simply <strong>copy</strong> the data instead of moving it.</p>
<p>Consider the below:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &quot;42_u64&quot;.to_string();
let y = x; // x *moved* into y. y now owns String value &quot;42_u64&quot;, x is gone.

let a = 42_u64;
let b = a; // a *copied* and assigned to b. We get two instances of value 42.

// This would be a compile-time error
//println!(&quot;Strings: {x}, {y}&quot;);

// This works
println!(&quot;Integers: {a}, {b}&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>It outputs:</p>
<pre><code class="language-ignore">Integers: 42, 42
</code></pre>
<p>Whereas the string <code>x</code> was <em>moved</em>, the 64-bit unsigned integer <code>a</code> was <em>copied</em>.
The assignment operation was still cheap, but it created a tiny duplicate instead of transferring ownership:</p>
<p align="center">
  <figure>
  <img width="100%" src="own_move_copy.svg">
  <figcaption><center>y now owns string "42_u64", a and b own separate instances of the integer 42</center></figcaption><br>
  </figure>
</p>
<p>The convenient part is that we don't have to think about ownership and moves, we can freely use our independent duplicates like the distinct values they are.
This makes working with primitive types, like integers and floats, much more ergonomic.
We get a welcome break from the cognitive load of Rust's move semantics.</p>
<p>Assignment performs a copy for any type that implements the <code>Copy</code> trait<sup class="footnote-reference"><a href="#TraitCopy">7</a></sup>.
You can derive or implement <code>Copy</code> for your own custom types if they don't hold externally-allocated data (like a <code>Vec</code> or <code>String</code> field).</p>
<p>Why not just have everything implement <code>Copy</code> and never worry about moves again?
Because duplicating data increases program runtime and memory consumption.
<code>Copy</code> isn't a good fit for large chunks of data, like most user-defined structures.
That's why, outside of day-to-day primitives, the <code>Copy</code> trait must be explicitly opted into.</p>
<h3 id="3-borrowing-for-a-subset-of-a-lifetime"><a class="header" href="#3-borrowing-for-a-subset-of-a-lifetime">3) Borrowing for a subset of a lifetime</a></h3>
<p>We saw borrowing in the previous section.
The idea was that we could get temporary access to a value by <em>reference</em>, without transferring ownership (performing a <em>move</em>) or duplicating data (performing a <em>copy</em>).</p>
<p>As a review, our reference-based <code>Proc</code> struct (note how the lifetime diagram added on the right differs from the prior move case):</p>
<pre><code class="language-rust ignore">// Alloc bash                                                           //
let bash = Proc::new(&quot;bash&quot;, State::Running, Vec::new());               // -------------------------+-- 'a
                                                                        //                          |
// Alloc rsyslogd, 1st move: bash -&gt; rsyslogd                           //                          |
let rsyslogd = Proc::new(&quot;rsyslogd&quot;, State::Running, vec![&amp;bash]);      // ------------------+-- 'b |
                                                                        //                   |      |
// Print owned value (new!)                                             //                   |      |
dbg!(&amp;bash);                                                            //                   |      |
                                                                        //                   |      |
// Alloc cron                                                           //                   |      |
let cron = Proc::new(&quot;cron&quot;, State::Sleeping, Vec::new());              // ----------+-- 'c  |      |
                                                                        //           |       |      |
// Alloc init, 2nd and 3rd moves: cron -&gt; init, rsyslogd -&gt; init        //           |       |      |
let init = Proc::new(&quot;init&quot;, State::Running, vec![&amp;cron, &amp;rsyslogd]);   // --+-- 'd  |       |      |
                                                                        //   |       |       |      |
// Print another owned value (new!)                                     //   |       |       |      |
dbg!(&amp;cron);                                                            //   |       |       |      |
                                                                        //   |       |       |      |
// Print serialized tree to see ownership hierarchy                     //   |       |       |      |
dbg!(&amp;init);                                                            // --+-------+-------+------+
</code></pre>
<p>Rust guarantees references are always safe to use.
References cannot <em>out-live</em> the value they refer to.
This implies they can only have <em>shorter</em> lifetimes in which they are <em>always valid</em>.
We can't have &quot;dangling pointers&quot;, which lead to temporal memory safety issues.
And thus are compliant with the below MISRA rule:</p>
<blockquote>
<p><strong>[AR, Rule 18.6]</strong> When an object's lifetime expires, so should the reference<sup class="footnote-reference"><a href="#MISRA_2012">8</a></sup></p>
</blockquote>
<p>Moreover, there's an infamous rule: &quot;shared XOR mutable&quot;.
Rust references can be either of (but never both):</p>
<ul>
<li>
<p><code>&amp;T</code> - immutable (cannot modify value referred to) and shared (more than reference can be in use simultaneously).</p>
<ul>
<li>References are immutable by <em>default</em>.</li>
</ul>
</li>
<li>
<p><code>&amp;mut T</code> - mutable (can modify value referred to) and exclusive (only one exists at any given point).</p>
<ul>
<li>References have to be <em>explicitly</em> marked mutable.</li>
</ul>
</li>
</ul>
<p align="center">
  <figure>
  <img width="100%" src="ref_venn_normal.svg">
  <figcaption><center>2 kinds of references: immutable/shared (&T) and mutable/exclusive (&mut T)</center></figcaption><br>
  </figure>
</p>
<p>Thus far, we've only shown the first case, often called a <em>shared reference</em>.
We'll learn how to work with the second case, dubbed a <em>mutable reference</em>, as we write more Rust code.
To preview the exclusive-mutable restriction, this code would fail to compile:</p>
<pre><code class="language-rust ignore">let mut x = &quot;Hello!&quot;.to_string();

let r1 = &amp;mut x; // 1st mutable borrow
let r2 = &amp;mut x; // 1nd mutable borrow - problem!

println!(&quot;{}, {}&quot;, r1, r2);
</code></pre>
<p>With the error:</p>
<pre><code class="language-ignore">error[E0499]: cannot borrow `x` as mutable more than once at a time
 --&gt; src/main.rs:7:10
  |
6 | let r1 = &amp;mut x; // 1st mutable borrow
  |          ------ first mutable borrow occurs here
7 | let r2 = &amp;mut x; // 1nd mutable borrow - problem!
  |          ^^^^^^ second mutable borrow occurs here
8 |
9 | println!(&quot;{}, {}&quot;, r1, r2);
  |                    -- first borrow later used here

For more information about this error, try `rustc --explain E0499`.
</code></pre>
<p>But this is OK:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = &quot;Hello!&quot;.to_string();

let r1 = &amp;mut x; // 1st mutable borrow

// Mutate the string
r1.pop();
r1.push_str(&quot;, World&quot;);

println!(&quot;Modified via r1: {}&quot;, r1);
// End of implicit (no open-close brackets) scope for 1st mutable borrow,
// b/c not used again in this function

let r2 = &amp;mut x; // 2nd mutable borrow - OK, not simultaneous!

// Mutate the string via another reference
r2.push('!');

println!(&quot;Modified via r2: {}&quot;, r2);
<span class="boring">}
</span></code></pre></pre>
<p>It prints:</p>
<pre><code class="language-ignore">Modified via r1: Hello, World
Modified via r2: Hello, World!
</code></pre>
<p>The trick with mutable borrows is the requirement that they remain <em>exclusive</em>.
Satisfying that requirement isn't always straightforward, it's a skill gained through experience.</p>
<h3 id="4-the-interior-mutability-pattern"><a class="header" href="#4-the-interior-mutability-pattern">4) The &quot;interior mutability&quot; pattern</a></h3>
<p>The first three ownership &quot;workarounds&quot; (moving, copying, and borrowing) are all that we'll need in this book.
But there's a fourth option, a well-known pattern in Rust.
It's called <strong>interior mutability</strong> and relaxes enforcement of the <code>&amp;T</code> xor <code>&amp;mut T</code> check.</p>
<p>We must still obey the rule, but we don't have to prove mutual exclusion for all possible executions with <em>compile-time verification</em> (static assurance).
That strictness makes encoding certain problems too difficult.
But if it compiles, it's guaranteed.</p>
<p>Instead, interior mutability allows us to do <em>runtime validation</em> (dynamic assurance).
Below are two types often used in the interior mutability pattern.
Don't worry about what these type signatures mean, let's focus on the tradeoffs:</p>
<ul>
<li>
<p><strong><code>Rc&lt;RefCell&lt;T&gt;&gt;</code>'s availability risk:</strong> if a statement in our code attempts to mutably borrow a value that another statement has already mutably borrowed, the thread will <code>panic!</code> (terminate immediately)<sup class="footnote-reference"><a href="#RefCell">9</a></sup>.</p>
<ul>
<li>E.g. risks terminating single-threaded applications.</li>
</ul>
</li>
<li>
<p><strong><code>Arc&lt;RwLock&lt;T&gt;&gt;</code>'s potential performance impact:</strong> - if thread A requests read access to data while thread B is holding a write lock, thread A is blocked (pauses execution) until thread B releases the lock. But multiple simultaneous readers are allowed<sup class="footnote-reference"><a href="#RwLock">10</a></sup>.</p>
<ul>
<li>
<p>E.g. risks performance degradation for multi-threaded applications.</p>
</li>
<li>
<p>A reader-writer lock is a common <em>synchronization</em> mechanism in systems programming. It's not unique to Rust.</p>
</li>
</ul>
</li>
</ul>
<p align="center">
  <img width="80%" src="ref_venn_interior_mut.svg">
  <figure>
  <figcaption><center>Interior mutability: runtime enforced shared readable xor exclusive writeable</center></figcaption><br>
  </figure>
</p>
<p>To reiterate, <strong>we will not be using interior mutability in this book.</strong>
We can build a feature-rich library without it.
And, because a compile-time guarantee doesn't require a fallible runtime check, our implementation will enjoy a higher level of assurance.</p>
<p>Interior mutability is still worth learning and using, eventually.
It's a best practice for some classes of problems, and well-covered in other resources<sup class="footnote-reference"><a href="#TRPL">11</a></sup>.
But remember - Rust is a <em>big</em> language.
We don't have to master every feature to be productive.</p>
<blockquote>
<p><strong>We're not out of the runtime woods!</strong></p>
<p>Our code does index-based array access, e.g. <code>arr[i]</code>.
That incurs a runtime bounds check.
A failure (out-of-bounds index attempt) would mean <code>panic!</code>, just like <code>RefCell</code>.
But array indexing is easier to reason about.</p>
<p>To justify confidence in indexing logic and more general reliability, Chapter 12 introduces an advanced form of stress testing: differential fuzzing.</p>
</blockquote>
<h2 id="takeaway"><a class="header" href="#takeaway">Takeaway</a></h2>
<p>We now have a more holistic view of ownership.
Including four ways to work with the borrow checker:</p>
<ol>
<li>
<p><strong>Moving</strong> (transferring) ownership from one variable to another.</p>
</li>
<li>
<p><strong>Copying</strong> (duplicating) data, creating a second, independent, owned instance.</p>
</li>
<li>
<p><strong>Borrowing</strong> (accessing) to data for a subset of its lifetime.</p>
</li>
<li>
<p><del><strong>Interior mutability</strong> - a form of relaxed, runtime ownership enforcement.</del></p>
</li>
</ol>
<p>That's it!
We've covered the most difficult and infamous aspect of the Rust programming language.
Keep these concepts in mind as we write more code, and soon ownership might even become second nature.</p>
<p>Ownership guarantees memory safety.
But Rust is also known for general correctness - for robustness beyond memory safety.
Its error handling story is a major reason for that reputation.
And our next topic.</p>
<hr />
<div class="footnote-definition" id="BorrowChecker"><sup class="footnote-definition-label">1</sup>
<p><a href="https://rustc-dev-guide.rust-lang.org/borrow_check.html"><em>MIR borrow check</em></a>. Guide to Rustc Development (Accessed 2022).</p>
</div>
<div class="footnote-definition" id="GeneralTrend"><sup class="footnote-definition-label">2</sup>
<p>At some level, that's also true of most Programming Language (PL) innovations (e.g. type systems and annotation-based frameworks).
And it complements the robustness benefits coming from industry development tools/practices (e.g. powerful IDEs and frameworks aiding product creation, and testing/deployment processes underpinning production-quality systems and services). Rust isn't special or a &quot;silver bullet&quot;, it's one of many modern development tools. But Rust does tackle an important niche: fast &amp;&amp; memory-safe.</p>
</div>
<div class="footnote-definition" id="CHESS"><sup class="footnote-definition-label">3</sup>
<p><a href="https://www.darpa.mil/attachments/CHESS-Slides-DISTAR.pdf"><em>CHESS: Computers and Humans Exploring Software Security</em></a>. Dustin Fraze (2018, Public Domain).</p>
</div>
<div class="footnote-definition" id="CHESSDesc"><sup class="footnote-definition-label">4</sup>
<p><a href="https://www.darpa.mil/program/computers-and-humans-exploring-software-security"><em>Computers and Humans Exploring Software Security (CHESS)</em></a>. William Martin (Accessed 2022).</p>
</div>
<div class="footnote-definition" id="ExampleCredit"><sup class="footnote-definition-label">5</sup>
<p>To give appropriate credit, this example is based on <a href="https://stackoverflow.com/questions/11137516/scope-vs-lifetime-of-variable">this StackOverflow question</a> and <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html">this part</a> of TRPL book. In particular, we use the same ASCII diagram comments of TRPL.</p>
</div>
<div class="footnote-definition" id="Gpp"><sup class="footnote-definition-label">6</sup>
<p>We compiled this program with command <code>g++ scope.cpp -o scope</code> using <code>g++</code> version 9.4.0 (latest shipping on Ubuntu 20.04 LTS at the time of this writing). No warning was emitted.</p>
</div>
<div class="footnote-definition" id="TraitCopy"><sup class="footnote-definition-label">7</sup>
<p><a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><em>Trait <code>std::marker::Copy</code></em></a>. The Rust Team (Accessed 2022).</p>
</div>
<div class="footnote-definition" id="MISRA_2012"><sup class="footnote-definition-label">8</sup>
<p><em>MISRA C: 2012 Guidelines for the use of the C language in critical systems (3rd edition)</em>. MISRA (2019).</p>
</div>
<div class="footnote-definition" id="RefCell"><sup class="footnote-definition-label">9</sup>
<p><a href="https://doc.rust-lang.org/std/cell/index.html"><em>Module <code>std::cell</code></em></a>. The Rust Team (Accessed 2022).</p>
</div>
<div class="footnote-definition" id="RwLock"><sup class="footnote-definition-label">10</sup>
<p><a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><em>Struct <code>std::sync::RwLock</code></em></a>. The Rust Team (Accessed 2022).</p>
</div>
<div class="footnote-definition" id="TRPL"><sup class="footnote-definition-label">11</sup>
<p><a href="https://doc.rust-lang.org/book/ch15-05-interior-mutability.html"><em><code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</em></a>. by Steve Klabnik, Carol Nichols (Accessed 2022).</p>
</div>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chp3/rust_4_own_1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../chp3/rust_6_error.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chp3/rust_4_own_1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../chp3/rust_6_error.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
